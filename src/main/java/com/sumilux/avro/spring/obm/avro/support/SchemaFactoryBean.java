package com.sumilux.avro.spring.obm.avro.support;

import org.apache.avro.Schema;
import org.apache.avro.reflect.ReflectData;
import org.apache.avro.specific.SpecificData;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.core.io.Resource;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;

/**
 * <P>Provides a consistent way to return a {@link org.apache.avro.Schema} object which is crucial for every use of Avro in serialization
 * <p>This factory can build up a {@link Schema schema} by looking at a generated Avro class (for example, you might use the Maven Mojo to
 * generate classes based on a schema or defintion at compile time).
 * <p>Alternatively, you can specify a standard {@link Resource Spring resource} and this factory will build the schema from the resource specified.
 * <p>Finally, you might specify an inline schema defintion as well (particularly attractive using Spring's XML-based configuration).
 *
 * @author Josh Long
 */
public class SchemaFactoryBean implements FactoryBean<Schema>, InitializingBean {
    private String schema;
    private Schema result;
    private Log log = LogFactory.getLog(getClass());
    private Resource location;
    private volatile boolean setup = false;

    private Class targetClass;

    private final Object lock = new Object();

    /**
     * <p/>
     * first attempts to consult the registry of known types ({@link SpecificData}). This registry specifically
     * speaks to the types that are generated by the Avro compiler
     * or those that are primitives or well known cases, like {@link String strings}.
     * <p/>
     * <P> Failing that, this will attempt to generate a {@link Schema} using reflection.
     * <p/>
     * <P> Failing that, this will return <CODE>null</CODE>.
     * </p>
     *
     * @param clazz the class you'd like to find a Schema for
     * @return the schema
     */
    protected Schema findSchemaFor(Class<?> clazz) {
        // lets see if we can do this lazily
        //

        Schema result = null;
        try {
            SpecificData specificData = SpecificData.get();
            result = specificData.getSchema(clazz);
        } catch (Throwable th) {
            if (log.isDebugEnabled()) {
                log.debug("Error: could not get the Schema by consulting 'SpecificData'", th);
            }
        }

        if (null != result) {
            return result;
        }

        try {
            ReflectData reflectData = ReflectData.get();
            result = reflectData.getSchema(clazz);
        } catch (Throwable th) {
            if (log.isDebugEnabled()) {
                log.debug("Error: could not get the Schema by consulting 'ReflectData'", th);
            }
        }
        return result;

    }

    /**
     * @param c
     */
    public SchemaFactoryBean(Class c) {
        this.result = findSchemaFor(c);
    }

    /**
     * builds the {@link #result} based on a JSON string. Particularly useful for in-situ
     * definitions (perhaps using the XML configuration approach?)
     */
    public SchemaFactoryBean(String schema) {
        this.schema = schema;
        Assert.notNull(this.schema, "the 'schema' must not be null");
        try {
            afterPropertiesSet();
        } catch (Exception e) {
            if (log.isErrorEnabled()) {
                log.error("something went wrong in trying to construct the Schema ");
            }
        }

    }


    /**
     * builds the {@link #result} based on a Spring resource, which it then uses to load the {@link Schema} through an {@link java.io.InputStream}.
     *
     * @param location the location (e.g., <CODE>'classpath:/foo/bar.avsc'</CODE>)
     */
    public SchemaFactoryBean(Resource location) {
        this.location = location;
        Assert.notNull(this.location, "the 'location' must not be null");
        try {
            afterPropertiesSet();
        } catch (Exception e) {
            if (log.isErrorEnabled()) {
                log.error("something went wrong in trying to construct the Schema ");
            }
        }
    }

    /**
     * <P> points to a location on (URL, file, etc.) for the file to be read in
     * <P> this option is mutually exclusive with the {@link #schema schema property}.
     *
     * @param location the location of a <CODE>.avpr</CODE> (or otherwise) file to read in
     */
    public void setLocation(Resource location) {
        this.location = location;
    }

    /**
     * <p> The schema itself might be defined inline, in the XML or Java configuration.
     * <p>this option is mutually exclusive with the {@link #location location property}
     *
     * @param schema the string for the schema itself.
     */
    public void setSchema(String schema) {
        this.schema = schema;
    }

    @Override
    public Schema getObject() throws Exception {
        afterPropertiesSet();
        return this.result;
    }

    @Override
    public Class<?> getObjectType() {
        return Schema.class;
    }

    @Override
    public boolean isSingleton() {
        return true;
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        synchronized (this.lock) {
            if (this.setup || this.result != null) {
                return;
            }

            boolean inline = StringUtils.hasText(this.schema);
            boolean external = location != null;
            boolean somethingsProvided = inline || external;

            Assert.isTrue(somethingsProvided, "the 'location' property or the 'schema' property must be set (but not both)");

            if (!StringUtils.hasText(schema)) {
                if (log.isDebugEnabled()) {
                    log.debug("the 'validate' property is ignored if you do not provide a schema JSON string defintion inline");
                }
            }

            if (inline) {
                result = Schema.parse(this.schema, true);
            } else {
                result = Schema.parse(this.location.getInputStream());
            }
            this.setup = true;
        }
    }

    public void setTargetClass(Class targetClass) {
        this.targetClass = targetClass;
    }
}
